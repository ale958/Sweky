<h2 class="page-header">Progettazione Software</h2>
<h3>Definizione</h3>
<p>
Una volta individuato in modo chiaro il problema tramite l'ingegneria dei requisiti(approccio analitico),
il compito di trovare la soluzione per risolvere il problema nel modo più corretto è compito della progettazione software(approccio sintetico).
<br/>
La progettazione ricerca una soluzione soddisfacente per tutti gli  <a class="glossar" title="Stakeholder" id="Stakeholder" tabindex="0" role="button" data-toggle="popover"  data-trigger="focus" data-content="Da mobile clicca di nuovo"
 onmouseover="getText('Stakeholder')" onclick="miao()">stakeholder</a>,
andando a produrre l'architettura e i suoi modelli
 logici senza l'ausilio del codice.
La progettazione ha dunque il compito di assicurare il soddisfacimento delle caratteristiche individuate per il prodotto durante
l'analisi.
<br/>
<br/>
L'<b>obiettivo</b> di una buona progettazione software è il soddisfacimento dei requisiti
con un sistema di qualità, ottenibile tramite la definizione di una buona architettura logica del prodotto
che presenti componenti dalle specifiche chiare e coese, che sia realizzabile con risorse e costi fissati e che abbia 
una struttura che faciliti cambiamenti futuri(manutenibile).
<br/>
Per dominare la complessità del sistema conviene scomporlo in componenti via via meno complessi, fermando la decomposizione una volta 
arrivati a componenti che abbiano complessità trattabile da un singolo individuo.
<br/>
<br/>
Importante è saper riconoscere quando terminare tale scomposizione per non occorrere in orchestrazioni tra componenti
troppo complesse e che farebbero annullare i benefici di tale scomposizione.
</p>

<blockquote>
L'architettura software è l’organizzazione di base di un sistema, espressa dai suoi
componenti, dalle relazioni tra di loro e con l’ambiente, e i principi
che ne guidano il progetto e l’evoluzione
<footer>ISO/IEC/IEEE 42010:2011, Systems
and software engineering — Architecture description</footer>
</blockquote>

<p>
Tipicamente l'architettura di un software è un <b>sistema</b>
formato da <b>componenti</b>, che raggruppano delle <b><a class="glossar" title="Unità" id="Unità" tabindex="0" role="button" data-toggle="popover"  data-trigger="focus" data-content="Da mobile clicca di nuovo" onmouseover="getText('Unità')" onclick="miao()">unità</a></b> che a loro volta raggruppano
<b>moduli</b>(carico di lavoro da assegnare ad un singolo).
<br/>
Acronimo di tale suddivisione è <b>SCUM</b>.
<br/>
Per perseguire coerenza e consistenza nell'architettura è consigliato l'uso di 
<a class="glossar" title="Stile architetturale" id="Stile architetturale" tabindex="0" role="button" data-toggle="popover"  data-trigger="focus" data-content="Da mobile clicca di nuovo" onmouseover="getText('Stile architetturale')" onclick="miao()">stili architetturali</a>,
che forniscono una soluzione progettuale di alto livello, specificando poi la progettazione di dettaglio mediante l'uso di design pattern appropriati.
<br/>
La progettazione di dettaglio si occupa di assegnare le unità a componenti per organizzare il lavoro di programmazione,
producendo della documentazione che possa disciplinare 
la programmazione, tracciando i requisiti alle unità
e definendo le configurazioni ammissibili del sistema.
Inoltre vengono definiti gli strumenti per eseguire le prove di unità.
</p>

<h4>SEMAT</h4>
<p>
SEMAT prevede quattro stati di progresso con cui poter valutare il grado con cui l'architettura è definita e implementata.
<br/>
Inizialmente il progresso viene catalogato come <b>architecture selected</b>, 
dove avviene la selezione delle tecnologie necessarie e delle decisioni architetturali in base ad esse.
<br/>
Una volta dimostrata agli stakeholders la bontà delle scelte architetturali e decise le principali interfacce e configurazioni di sistema l'architettura si attesta 
a <b>demonstrable</b>.
In seguito alla sviluppo dell'architettura scelta, quando il sistema può essere utilizzato dagli utenti e presenta le funzionalità e le prestazioni richieste,
con una quantità di difetti residui accettabile si raggiunge lo stato di <b>usable</b>.
<br/>
Infine al termine della stesura della documentazione e con l'accettazione degli stakeholders del prodotto si raggiunge lo stato 
<b>ready</b>.

</p>



<h3>Qualità di architettura</h3>
<p>
Le qualità che generalmente dovrebbe avere una buona architettura dovrebbero essere misurabili, in modo da poter evidenziare cambiamenti
nel tempo tramite misurazioni, esse sono:
</p>
<ul>
<li><b>Sufficienza</b>: cioè un sufficiente grado di soddisfacimento dei requisiti;</li>
<li><b>Comprensibilità</b>: dovrebbe essere compresa dagli stakeholders;</li>


<li><b>Modularità</b>: buona scomposizione in componenti, parti chiare e distinte tra loro e con compiti non sovrapposti;</li>

<li><b>Robustezza</b>: gestione di diverse classi di input(anche non previste);</li>

<li><b>Flessibilità</b>: che permetta facile manutenzione sia adattativa che evolutiva;</li>

<li><b>Riusabilità</b>: sia pensata anche per il <a class="glossar" title="Riuso" id="Riuso" tabindex="0" role="button" data-toggle="popover"  data-trigger="focus" data-content="Da mobile clicca di nuovo" onmouseover="getText('Riuso')" onclick="miao()">riuso</a> e con il riuso di componenti;</li>

<li><b><a class="glossar" title="Efficienza" id="efficienza" tabindex="0" role="button" data-toggle="popover"  data-trigger="focus" data-content="Da mobile clicca di nuovo" onmouseover="getText('Efficienza')" onclick="miao()">Efficienza</a></b>;</li>

<li><b>Affidabilità</b>: è altamente probabile che svolga bene il suo compito;</li>

<li><b>Disponibilità</b>: la manutenzione che blocca l'intero sistema dovrebbe essere breve o nulla, la manutenzione di una parte di sistema non deve bloccarlo interamente;</li>

<li><b>Sicurezza rispetto ai malfunzionamenti</b>: il sistema dispone di un sufficiente grado di ridondanza;</li>

<li><b>Sicurezza rispetto a intrusioni</b>: protezione dei dati del sistema;</li>
<li><b>Semplicità</b>: caratteristica riferita alla complessità dell'architettura;</li>
<li><b>Incapsulamento</b>: alcune volte nascondere i dettagli implementativi(black box) può portare a benefici come diminuzione di dipendenze e aumento di riuso, a volte accresce anche la <a class="glossar" title="Manutenibilità" id="Manutenibilità" tabindex="0" role="button" data-toggle="popover"  data-trigger="focus" data-content="Da mobile clicca di nuovo" onmouseover="getText('Manutenibilità')" onclick="miao()">manutenibilità</a>;</li>
<li><b><a class="glossar" title="Coesione" id="Coesione" tabindex="0" role="button" data-toggle="popover"  data-trigger="focus" data-content="Da mobile clicca di nuovo" onmouseover="getText('Coesione')" onclick="miao()">Coesione</a></b>: parti associate concorrono agli stessi obiettivi;</li>

<li><b>Basso <a class="glossar" title="Accoppiamento" id="Accoppiamento" tabindex="0" role="button" data-toggle="popover"  data-trigger="focus" data-content="Da mobile clicca di nuovo" onmouseover="getText('Accoppiamento')" onclick="miao()">Accoppiamento</a></b>: parti distinte dipendono
 il meno possibile le une dalle altre.</li>

</ul>
<p>
In particolare l'accoppiamento tra le componenti 
va minimizzato, per fare ciò spesso si può far interagire tra loro
le componenti tramite interfacce, evitando cosi di fare assunzioni
dall'esterno sull'interno e evitando di condividere frammenti di stesse risorse.
<br/>
Il grado di accoppiamento è misurabile:
per ogni componente il numero di archi entranti viene detto <b>fan-in</b> ed è indice
di utilità e va quindi massimizzato, mentre il numero di archi uscenti viene
 detto <b>fan-out</b> ed indica dipendenza e va quindi minimizzato.

</p>


<h3>
Stili di progettazione architetturale
</h3>
<p>
Nell'approcciarsi alla progettazione architetturale si possono seguire tre diversi stili
di progettazione:
lo stile funzionale(top-down) prevede la decomposizione di problemi
partendo dalle funzionalità di alto livello e scendendo poi nel dettaglio, ogni parte del sistema viene poi rifinita fino ad ottenere
una specifica sufficientemente completa da validare il modello.
<br/>
Nello stile object-oriented(bottom-up) invece vengono prima individuate 
le parti del sistema in dettaglio e poi connesse tra loro in modo 
da formare componenti più grandi, fino alla realizzazione dell'intero sistema.<br/>
Questo approccio 
privilegia la codifica e una <a class="glossar" title="Fase" id="Fase" tabindex="0" role="button" data-toggle="popover"  data-trigger="focus" data-content="Da mobile clicca di nuovo"
 onmouseover="getText('Fase')" onclick="miao()">fase</a> di test precoce, che può iniziare 
appena il primo modulo è stato specificato.
<br/>
Uno dei principali vantaggi dell'uso dell'approccio bottom-up
è la riusabilità.
<br/>
L'approccio più frequentemente seguito è quello intermedio che prende nome di
<b>meet-in-the-middle</b> che permette maggiore flessibilità.
</p>

<h3>Strumenti di supporto</h3>
<p>
Alcune scelte di progettazione vengono influenzate dall'uso di particolari framework, che loro volta possono indurre a introdurre 
specifici design pattern.
<br/>
Un <b>framework</b> è un insieme integrato di componenti software prefabbricate(simili ad una libreria) che forniscono una base facilmente
riusabile per una grande varietà di applicazioni in un dato dominio.
Forniscono un approccio <b>bottom-up</b> perché sono costituiti da codice già fatto, quindi già specificato in dettaglio, ma anche un approccio <b>top-down</b>
poiché a volte impongono stili architetturali.
<br/>
Un <b>design pattern</b> costituisce una soluzione progettuale di riconosciuta bontà ad un problema ricorrente lasciando comunque un certo grado di libertà
di progettazione.
<br/>
In particolare per la progettazione del sistema esistono dei pattern architetturali, di cui i più comuni sono:
</p>
<ul>
<li><b>A livelli</b>: l'architettura viene suddivisa in più livelli con responsabilità distinte e delle interazioni definite.
Di particolare utilizzo è quella a tre livelli che suddivide il livello di presentazione, il livello di logica operativa e quello di dati persistenti. I livelli possono anche essere più numerosi come avviene nella pila OSI e 
ciò può portare a molte richieste per comunicare con livelli non adiacenti;</li>


<li><b>Produttore-consumatore</b>: consiste nella collaborazione a pipeline con utilizzo di una coda;</li>


<li><b>Client-server</b>: architettura strutturata a livelli in due macchine distinte che comunicano tramite un protocollo.
Si può strutturare come <b>fat client</b> la comunicazione con più client porta il server a parlare direttamente con l'applicazione
e poiché il client possiede di per sé una parte della logica; mentre si parla di <b>thin client</b> se la comunicazione è più ad alto livello e 
si ha quindi una buona portabilità ma un carico maggiore sul server.</li>


<li><b>Peer-to-peer</b>: architettura che prevedere la connessione tra varie macchine che comunicano tra loro senza bisogno di un server intermedio.</li>

</ul>


<script>
					$(function(){
						$("[data-toggle=popover]").popover();
					});
</script>

<iframe width="100%" height="500" allowfullscreen frameborder="0" src="https://bubbl.us/NDE1NTc2Ny84MTg0ODk4Lzg5ZDM2MWUzYTUxNjFkMjlhZDczOTUyNmRhZDIwNzEw-X?utm_source=page-embed&utm_medium=link&s=8184898"></iframe>
